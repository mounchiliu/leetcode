https://www.lintcode.com/problem/longest-palindromic-substring/description


my trun:
SOL1: Naive
class Solution {
public:
    /**
     * @param s: a string which consists of lowercase or uppercase letters
     * @return: the length of the longest palindromes that can be built
     */
    string longestPalindrome(string &s) {
        // write your code here
        int i,j;
        int longestlength = 0;
        int start = 0;
        for(i = 0; i < s.length(); i++){
            for(j = i; j < s.length(); j++){
                int length = j - i + 1;
                if(length > longestlength && isPalindrome(s,i,j)){
                    start = i;
                    longestlength = length;
                }
                
                
            }
        }
        
        return s.substr(start,longestlength);//c++ string 的用法！！！
                                                //strVariable.substring(start, len)
        
    }
    
    
    
    bool isPalindrome(string &s, int i, int j){
        while(i<j && s[i]==s[j]){
            i++;//move to right
            j--;//move to left
        }
        //until two pointer encounter with each other-->valid palindrome
        
        return i>=j; //【Note】
        
        //if(i>=j){
       //     return true;
        //}
        //return false;
    }
};



SOL2:
class Solution {
public:
    /**
     * @param s: a string which consists of lowercase or uppercase letters
     * @return: the length of the longest palindromes that can be built
     */
    string longestPalindrome(string &s) {
        // write your code here

        //优化:找最长的回文子串，反过来找，那么第一个找到的就应该是最优的 【SOL2】
        //但是时间复杂度（最坏情况依然和上面一样是O(n^3)
        int len,l,r,i;
        for(len = s.length(); len > 0; len --){ 
            for(i = 0; i < s.length()-len+1; i++){ //s.length()-len+1为i起点的极限值（画图可知）
                l = i; r = i + len - 1;//index
                while(i<r&&s[l]==s[r]){
                    l++;
                    r--;
                }
                if(i>=r){
                    return s.substr(i,len);//the first one must be the result
                }
            }
        }
        
        return "";
        
    }



SOL3:
class Solution {
public:
    /**
     * @param s: a string which consists of lowercase or uppercase letters
     * @return: the length of the longest palindromes that can be built
     */
     
    const int expandAroundCenter(string &s, int left, int right){
        while(s[left] == s[right] && left>=0 && right<s.length()){ //left,right 边界检查
            left--;
            right++;
        }
        //return length
        return (right-left-1);    //注意: left,right不满足条件时跳出循环，所以是(right-1-【left+1】)+1 处为最后的length
        
    }
     
     
     
    string longestPalindrome(string &s) {
        // write your code here
        int start,end, longestlen = 0;
        for(int i = 0; i<s.length(); i++){
            const int len1 = expandAroundCenter(s,i,i);//奇数回文 //对当前对称轴搜索回文串，返回最长的
            const int len2 = expandAroundCenter(s,i,i+1);//偶数回文 注意:const 用法
            
            int len = max(len1,len2); //c++ max用法
            
            //update start and length
            if(len>longestlen){
                start = i - floor((len-1)/2) ;//可以举例算出来 同时适用于奇偶数
                longestlen = len;
            }
        }
        
        return s.substr(start,longestlen);
    }

};



BEST SOL: dynamic programming
