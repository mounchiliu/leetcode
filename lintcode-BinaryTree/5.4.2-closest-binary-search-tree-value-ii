https://www.lintcode.com/problem/closest-binary-search-tree-value-ii/description
5.4的follow up：寻找k个最接近的值
思路：找到target的lowerbound和upperbound，两个指针一个找前驱，一个找后序
时间复杂度是O(k+h) h为高度

实现如下的子函数：
- getStack() => 在假装插入 target 的时候，看看一路走过的节点都是哪些，放到 stack 里，用于 iterate
- moveUpper(stack) => 根据 stack，挪动到 next node
- moveLower(stack) => 根据 stack, 挪动到 prev node
有了这些函数之后，就可以把整个树当作一个数组一样来处理，只不过每次 i++ 的时候要用 moveUpper，i--的时候要用 moveLower


/**
 * Definition of TreeNode:
 * class TreeNode {
 * public:
 *     int val;
 *     TreeNode *left, *right;
 *     TreeNode(int val) {
 *         this->val = val;
 *         this->left = this->right = NULL;
 *     }
 * }
 */

class Solution {
public:
    /**
     * @param root: the given BST
     * @param target: the given target
     * @param k: the given k
     * @return: k values in the BST that are closest to the target
     */
    vector<int> closestKValues(TreeNode * root, double target, int k) {
        // write your code here
        if(k == 0 || root == NULL)
            return {};
        
        //get boundaries
        stack<TreeNode*> lowerStack;
        stack<TreeNode*> upperStack;
        while(root != NULL){
            if(target < root->val){
                 upperStack.push(root);
                 root = root->left;
            }
            else{
                lowerStack.push(root);
                root = root->right;
            }
        }
        
        //get k elements
        vector<int> result;
        for(int i = 0; i < k; i++){
            if(lowerStack.empty()){ //k<=node总数，所以一个为空，另一个一定不为空
                result.push_back(upperStack.top()->val);
                moveup(upperStack);
                continue;
            }
            if(upperStack.empty()){
                result.push_back(lowerStack.top()->val);
                moveless(lowerStack);
                continue;
            }
            if(target - lowerStack.top()->val < upperStack.top()->val - target){
                result.push_back(lowerStack.top()->val);
                moveless(lowerStack);
            }else{
                result.push_back(upperStack.top()->val);
                moveup(upperStack);
            }
        }
        return result;
    }
private:
    void moveless(stack<TreeNode*>& lStack){
        TreeNode* node = lStack.top();
        lStack.pop();
        if (node->left){
            node = node->left;
            while (node){
                lStack.push(node);
                node = node->right;
            }
        }
    }
    
    void moveup(stack<TreeNode*>& rStack){
        TreeNode* node = rStack.top();
        rStack.pop();
        if (node->right){
            node = node->right;
            while (node){
                rStack.push(node);
                node = node->left;
            }
        }
    }
};

