https://www.lintcode.com/problem/sequence-reconstruction/description

My solution 
- First temp:(Got error) failed on case input: org,seqs
                                        [1],[] -> should return false.
                                        [], [[]] -> should return true
class Solution {
public:
    /**
     * @param org: a permutation of the integers from 1 to n
     * @param seqs: a list of sequences
     * @return: true if it can be reconstructed only one or false
     */
    bool sequenceReconstruction(vector<int> &org, vector<vector<int>> &seqs) {
        // write your code here
        
        //org是父序列，应包含所有的元素
        //这题和course schedule有异曲同工之妙
        unordered_map<int,unordered_set<int>> element_seq;//record sequence element 
        //这边不能像course schedule里用vector因为这里的数字可能是无序的 例如 example 4
        unordered_map<int,int> cnt_indegree;
        
        for(int &n: org){
            //for each element, initialize it;
            element_seq[n] = unordered_set<int>();
        }
        
        
        //统计入度
        for(auto &seq: seqs){
            for(int i = 0; i < seq.size()-1; i++){
                element_seq[seq[i]].insert(seq[i+1]);
                cnt_indegree[seq[i+1]]++;
            }
        }
        
        
        queue<int> Q;
        for(int i = 0; i < cnt_indegree.size(); i++){
            if(cnt_indegree.count(i)==0){ //【Note】map.count(element)
                Q.push(cnt_indegree[i]);
            }
        }

        
        //Determine whether there is only one sequence that can be reconstructed from seqs and it is the org sequence. --> BFS
        int num = 0;
        while(!Q.empty()){
            int head = Q.front();
            Q.pop();
            if(head!=org[num])
                return false;
            num++;
            
            
            for(auto &set_ele: element_seq[head]){
                cnt_indegree[set_ele]--;
                
                if(cnt_indegree.count(set_ele)==0){
                    Q.push(set_ele);
                }
            
            
            }
        }
        
        return true;


    }
};


- second temp accpeted
class Solution {
public:
    /**
     * @param org: a permutation of the integers from 1 to n
     * @param seqs: a list of sequences
     * @return: true if it can be reconstructed only one or false
     */
    bool sequenceReconstruction(vector<int> &org, vector<vector<int>> &seqs) {
        // write your code here
        

        
        //org是父序列，应包含所有的元素
        //这题和course schedule有异曲同工之妙
        unordered_map<int,unordered_set<int>> element_seq;//record sequence element 
        //这边不能像course schedule里用vector因为这里的数字可能是无序的 例如 example 4
        unordered_map<int,int> cnt_indegree;
        
        for(int &n: org){
            //for each element, initialize a set to it;
            element_seq[n] = unordered_set<int>();
            cnt_indegree[n] = 0;//initilize count value
            
        }
        
        
        //统计入度
        int count = 0;
        for(auto &seq: seqs){
            count += seq.size();
            if (seq.size() >= 1 && (seq[0] <= 0 || seq[0] > org.size())) //首先判断size会不会导致越界！
                return false;
            for(int i = 1; i < seq.size(); i++){
                //判断seq里的元素的合理性
                if(seq[i]<1 || seq[i] > org.size()){ 
                    return false;
                }
                
                if(element_seq[seq[i-1]].count(seq[i])==0){//this seq has not been recorded by map
                    element_seq[seq[i-1]].insert(seq[i]);
                    cnt_indegree[seq[i]]++;
                }
            }
        }
        
        //for case [1] []
        if(count<org.size())
            return false;
        
        queue<int> Q;
        for(auto &temp: cnt_indegree){
            if(temp.second==0){ //【Note】map.count(element)
                Q.push(temp.first);//first = key, second = value;
            }
        }

        
        //Determine whether there is only one sequence that can be reconstructed from seqs and it is the org sequence. --> BFS
        int num = 0;
        while(Q.size()==1){//queue中最多同时只有一个节点
            int head = Q.front();
            Q.pop();
            if(head!=org[num])
                return false;
            num++;
            
            
            for(const int &set_ele: element_seq[head]){
                cnt_indegree[set_ele]--;
                
                if(cnt_indegree[set_ele]==0){ //分清 count和直接访问的区别  count返回匹配给定主键的元素的个数，直接访问是访问这个key下储存的对应的值
                    Q.push(set_ele);
                }
            }
        }
        
        return num == org.size();


    }
};
