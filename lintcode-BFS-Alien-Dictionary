https://www.lintcode.com/problem/alien-dictionary/description


//题解：

//利用suc存储某个字符的全部后缀(即优先级小于当前字符)，利用pre存储某个字符的全部前缀(即优先级大于当前字符)，chars存储全部出现的字符。
//在构建前缀和后缀map的过程中，s存储上一个字符串，t存储当前字符串，模拟字典序比较，按位比较，不相同说明当前字符是上一个字符串对应位置字符的后缀
//free存储拓扑排序当前的起点（即入度为0的字符），故首先遍历pre，因为p.first一定有前缀，不能作为起点，先从free中清除。
//每次取出free的头部，即为起点，加入答案中，然后清除，遍历后缀，找连接着起点的字符，如果字符前缀为空，也为起点，加入free。


class Solution {
public:
    /**
     * @param words: a list of words
     * @return: a string which is correct order
     */
     
    //首先construct graph, 你有多少个字母就有多少个点。 出现的字母建一个点
    //construct edge, 任何两个单词之间，找出不相同的字符， 排在在前的字符里的不同的字母顺序一定在前。
    //在构建拓扑sorting
    
    string alienOrder(vector<string>& words) {
        map<char, set<char>> suc, pre;
        set<char> chars;
        string s;
        for (string t : words) {
            chars.insert(t.begin(), t.end());
            for (int i=0; i<min(s.size(), t.size()); ++i) {
                char a = s[i], b = t[i];
                if (a != b) {
                    suc[a].insert(b);    	//保存每个字符的前缀和后缀
                    pre[b].insert(a);
                    break;
                }
            }
            s = t;
        }     
        set<char> free = chars;     //free保存拓扑排序的起点
        for (auto p : pre)      
            free.erase(p.first);    //去除有前缀的字符
        string order;               
        while (free.size()) {
            char a = *begin(free);   //free的首个字符，即为起点
            free.erase(a);           //除去字符
            order += a;              //加入答案
            for (char b : suc[a]) {    //遍历a的后缀
                pre[b].erase(a);       //从b的前缀中删除a
                if (pre[b].empty())    //如果前缀为空，可以作为拓扑排序的起点
                    free.insert(b);    //存入free
            }
        }
        return order.size() == chars.size() ? order : "";// 图中有环--> 不对，返回空串
    }
};
