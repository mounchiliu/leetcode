https://www.lintcode.com/problem/lru-cache/

用来衡量最后访问时间，决策cache中放谁，满了踢谁，以及排列的顺序(后进来的顺序在前，或者一进来-又最先进来一次)，从而实现chache的快速访问
思路:1. 寻找一个数据结构，可以保证能快速剔除中间节点，且挪到最后 (链表 可以O(1)完成) --- 注意改动节点位置后，需要知道它前面的和后面的值，所以需要使用双向链表(pre、next)
(【如果使用单向链表, 只要在hashmap中每个key存前一个值】
2. 寻找一个数据结构，可以通过key得到对应value --- hashmap
3. 需要知道中间某个节点在链表中的位置---需要存储每个key在链表中的位置

所以 我们使用hashmap + 链表
hashmap 中是 key - Listnode，且每个key都对应前一个Listnode (单向链表，使用这样的操作来记录前驱, 链表又自带后驱的记录功能)


